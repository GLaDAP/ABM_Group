"""
GROUP: LIMPENS (9)
DATE: 18 January 2021
AUTHOR(S): Karlijn Limpens
           Joos Akkerman
           Guido Vaessen
           Stijn van den Berg
           David Puroja 
DESCRIPTION: 
"""
from mesa import Agent
from .walker import Walker
from .agents import Elk

import random
import logging


class Wolf(Walker):
    """
    A wolf that walks around, reproduces (asexually) and eats elk.
    """
    def __init__(self, unique_id, pos, model, moore, energy=None):
        """
        Create a Wolf.
        Args:
            unique_id        (int): ID Generated by Mesa
            pos            (tuple): Tuple with the coordinates
            model     (mesa.Model): Model-object
            moore           (bool): Whether the model uses Moore neighborhood.
            energy           (int): Initial energy
        """
        super().__init__(unique_id, pos, model, moore=moore)
        self.energy = energy
        self.kills = 0
        self.pack = False

    def filter_func(self, agents):
        """
        Filter wolves from list.
        Args:
            agents (list): The list of agents to filter.
        """
        return [
            agent for agent in agents 
            if agent.energy < self.model.energy_threshold and not agent.pack
        ]

    def filter_packs(self, packs):
        """
        Filter packs from list
        Args:
            packs (list): The list of packs to filter.
        """
        return [
            pack for pack in packs 
            if len(pack) < self.model.pack_size_threshold
        ]

    def step(self):
        """
        Step function for the Wolf-object.
        """
        logging.debug("Wolf info ID: {}, PACK: {}, POS: {}".format(self.unique_id, self.pack, self.pos))
        if (self.pack):
            # If part of a pack, the pack controls the Wolf and the rest is
            # skipped. This should not happen and seeing this line indicates
            # an error in the model.
            logging.debug("Wolf {} part of pack.".format(self))
            return
        
        self.random_move()
        self.energy -= 1
        if self.energy < 20:
            """
            A wolf first tries to create a pack to hunt down an Elk.
            If that is not possible, a Wolf tries to kill the elk, but with
            a smaller probability of success.
            """
            pack = self.move_towards_specified_kind(Pack, 4, self.filter_packs)
            if (pack):
                pack.add_wolf_to_pack(self)
                return

            agent = self.move_towards_own_kind(4, self.filter_func)
            if (agent):
                pack = Pack(
                    self.model.next_id(), 
                    self.pos, 
                    self.model, 
                    [], 
                    self.moore, 
                    self.model.pack_size_threshold
                )
                self.model.schedule.add(pack)
                self.model.grid.place_agent(pack, pack.pos)
                pack.add_wolf_to_pack(agent)
                pack.add_wolf_to_pack(self)
                return
            else:
                # See if there are Elks available
                this_cell = self.model.grid.get_cell_list_contents([self.pos])
                elk = [obj for obj in this_cell if isinstance(obj, Elk)]

                if len(elk) > 0:
                    if (random.random() < 0.1):
                        elk_to_eat = self.random.choice(elk)
                        self.energy += self.model.wolf_gain_from_food

                        # Kill the elk
                        self.kills += 1
                        self.model.grid.remove_agent(elk_to_eat)
                        self.model.schedule.remove(elk_to_eat)

        # Death or reproduction
        if self.energy < 0:
            self.death()
        else:
            if self.random.random() < self.model.wolf_reproduce:
                # Create a new wolf cub
                self.energy /= 2
                cub = Wolf(
                    self.model.next_id(),
                    self.pos,
                    self.model,
                    self.moore,
                    self.energy
                )
                self.model.grid.place_agent(cub, cub.pos)
                self.model.schedule.add(cub)

    def death(self):
        """
        Removes a dead wolf from the model.
        """
        logging.debug("Wolf died.")
        self.pack = False
        self.model.grid.remove_agent(self)
        self.model.schedule.remove(self)

    # Equality operators to overrule comparison in the heapq
    def __eq__(self, other):
        self.__class__ == other.__class__ and self.pos == other.pos

    def __lt__(self, other):
        return True


class Pack(Walker):
    """
    Agent which holds a collection of wolves. Wolves are added to the pack and
    when the pack is large enough and finds an Elk, it eats and the pack is
    disbanded.
    """
    def __init__(
        self,
        unique_id,
        pos,
        model,
        wolves: list,
        moore: bool,
        pack_size_threshold: int
    ):
        """
        Create a Pack.
        Args:
            unique_id        (int): ID Generated by Mesa
            pos            (tuple): Tuple with the coordinates
            model     (mesa.Model): Model-object
            wolves          (list): List of Wolves initial
            moore           (bool): Whether the model uses Moore neighborhood.
        """
        super().__init__(unique_id, pos, model, moore=moore)
        self.wolves = wolves
        self.min_pack = pack_size_threshold
        for wolf in wolves:
            self.add_wolf_to_pack(wolf)

    def step(self):
        """
        Step function for the Pack.
        """
        logging.debug("Wolf pack size {}".format(len(self.wolves)))
        if (len(self.wolves) < self.min_pack):
            self.find_wolf_for_pack()
            logging.debug("Pack size below minimum")
        else:
            logging.debug("Pack up to size. Start searching for Elk.")
            if (self.move_towards_specified_kind(Elk, self.model.wolf_territorium) is None):
                # No elk found, move random.
                self.random_move()

        # Check for elks in this cell grid. The pack already moved to this
        # cell containing an Elk.
        this_cell = self.model.grid.get_cell_list_contents([self.pos])
        elk = [obj for obj in this_cell if isinstance(obj, Elk)]

        if (len(elk) > 0 and len(self.wolves) >= self.model.pack_size_threshold):
            # Pack eats the elk, pack is going to disband.
            self.pack_has_eaten(elk)
            return

        for wolf in self.wolves:
            wolf.energy -= 1
            if (wolf.energy < 0):
                logging.debug("Wolf died while in pack")
                wolf.pack = False
                self.wolves.remove(wolf)
                continue
            if self.random.random() < self.model.wolf_reproduce:
                logging.debug("Wolf born in pack")
                wolf.energy /= 2
                cub = Wolf(
                    self.model.next_id(),
                    self.pos,
                    self.model,
                    self.moore,
                    wolf.energy
                )
                cub.pack = True
                self.wolves.append(cub)
                logging.debug("Wolf born with ID: {}".format(cub.unique_id))
        if (len(self.wolves) < 2):
            logging.debug("Disbanding small pack")
            for wolf in self.wolves:
                self.remove_from_pack(wolf)
            self.model.grid.remove_agent(self)
            self.model.schedule.remove(self)

    def filter_func_pack(self, packs):
        """
        Filter the list of packs.
        Args:
            packs (list): List of packs to filter.
        """
        return [pack for pack in packs if len(pack.wolves) < self.min_pack]

    def filter_wolves(self, agents):
        """
        Filter the list of wolves.
        Args:
            agents (list): List of wolf-agents to filter.
        """
        return [
            agent for agent in agents if agent.energy < 20 and not agent.pack
        ]

    def find_wolf_for_pack(self):
        """
        Find a wolf in the neighborhood.
        """
        agent = self.move_towards_specified_kind(Wolf, 4, self.filter_wolves)
        if (agent):
            logging.debug("Next wolf found is: {}".format(agent))
            logging.debug("Pack size is now {}".format(len(self.wolves)))
            self.add_wolf_to_pack(agent)
        else:
            self.find_pack_for_pack()

    def find_pack_for_pack(self):
        """
        Find a pack in the neighborhood.
        """
        pack = self.move_towards_specified_kind(Pack, 4, self.filter_func_pack)
        if (pack):
            logging.debug("Next pack found is: {}".format(pack))
            logging.debug("Pack size is now {}".format(len(self.wolves)))
            self.add_pack_to_pack(pack)

    def add_pack_to_pack(self, pack):
        """
        Add a pack to this pack and dissolve the other one.
        Args:
            pack (Agent): Pack-object to merge with this pack.
        """
        logging.debug("Merging packs")
        for wolf in pack.wolves:
            self.add_wolf_to_pack(wolf)
        logging.debug("Pack is now {} wolves".format(len(self.wolves)))
        self.model.schedule.remove(pack)
        self.model.grid.remove_agent(pack)

    def add_wolf_to_pack(self, wolf):
        """
        Add wolf to pack.
        Args:
            wolf (Agent): The Wolf-object to add to the pack.
        """
        logging.debug("Adding wolf {} to pack".format(wolf.unique_id))
        # When a Wolf is part of a pack
        if (not wolf.pack):
            self.model.schedule.remove(wolf)
            self.model.grid.remove_agent(wolf)
        wolf.pack = True
        self.wolves.append(wolf)

    def remove_from_pack(self, wolf):
        """
        Remove wolf from this pack.
        Args:
            wolf (Agent): The Wolf agent to remove from the pack.
        """
        logging.debug("Removing Wolf")
        logging.debug("Wolf info ID: {}, PACK: {}, POS: {}".format(wolf.unique_id, wolf.pack, wolf.pos))
        wolf.pack = False
        self.model.schedule.add(wolf)
        self.model.grid.place_agent(wolf, self.pos)
        self.wolves.remove(wolf)

    def pack_has_eaten(self, elk):
        """
        Pack has eaten. Add kills to wolf, add energy and disband the pack.
        Args:
            elk (Agent): The Elk-agent to eat.
        """
        elk_to_eat = self.random.choice(elk)
        # Remove elk
        self.model.grid.remove_agent(elk_to_eat)
        self.model.schedule.remove(elk_to_eat)
        logging.debug('Pack has eated, disbanding pack with size {}'.format(len(self.wolves)))
        for wolf in self.wolves:
            wolf.energy += self.model.wolf_gain_from_food
            wolf.kills += 1
            self.remove_from_pack(wolf)
        # Remove pack from scheduler
        self.model.grid.remove_agent(self)
        self.model.schedule.remove(self)

    # Equality operators to overrule comparison in the heapq.
    def __eq__(self, other):
        self.__class__ == other.__class__ and self.pos == other.pos

    def __lt__(self, other):
        return True

    def __len__(self):
        return len(self.wolves)