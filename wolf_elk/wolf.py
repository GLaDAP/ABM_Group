"""
GROUP:       LIMPENS (9)
DATE:        18 January 2021
AUTHOR(S):   Karlijn Limpens
             Joos Akkerman
             Guido Vaessen
             Stijn van den Berg
             David Puroja
DESCRIPTION: This class contains two definitions for agents: Wolf-Agents and
             Pack-agents. A Wolf-agent moves freely as an individual in the
             model until it gets hungry: then it joins a Pack to attack an Elk.
"""
from mesa import Agent
from .walker import Walker
from .agents import Elk

import random
import logging
import numpy as np


class Wolf(Walker):
    """
    A wolf that walks around, reproduces (asexually) and eats elk.
    """
    def __init__(self, unique_id, pos, model, moore, energy):
        """
        Create a Wolf.
        Args:
            unique_id        (int): ID Generated by Mesa
            pos            (tuple): Tuple with the coordinates
            model     (mesa.Model): Model-object
            moore           (bool): Whether the model uses Moore neighborhood.
            energy           (int): Initial energy
        """
        super().__init__(unique_id, pos, model, moore=moore)
        self.energy = energy
        self.kills = 0
        self.pack = False

    def filter_func(self, agents):
        """
        Filter wolves from list which are not part of a pack and also want to
        eat.
        Args:
            agents (list): The list of agents to filter.
        Returns:
            List of agents.
        """
        return [
            agent for agent in agents
            if agent.energy < self.model.energy_threshold and not agent.pack
        ]

    def filter_packs(self, packs):
        """
        Filter packs from list which are below the pack size threshold.
        Args:
            packs (list): The list of packs to filter.
        Returns:
            List of agents.
        """
        return [
            pack for pack in packs
            if len(pack) < self.model.pack_size_threshold
        ]

    def step(self):
        """
        Step function for the Wolf-object.
        """
        logging.debug("Wolf info ID: {}, PACK: {}, POS: {}".format(
            self.unique_id, self.pack, self.pos)
        )
        if (self.pack):
            # If part of a pack, the pack controls the Wolf and the rest is
            # skipped. This should not happen and seeing this line indicates
            # an error in the model.
            logging.debug("Wolf {} part of pack. Check scheduler for \
                inconsistencies. A wolf is somewhere not correctly added or \
                removed from the scheduler.".format(self))
            return

        self.random_move()
        self.energy -= 1
        if self.energy < self.model.energy_threshold:
            """
            A wolf first tries to create a pack to hunt down an Elk.
            If that is not possible, a Wolf tries to kill the elk, but with
            a smaller probability of success.
            """
            pack = self.move_towards_specified_kind(
                Pack, self.model.wolf_territorium, self.filter_packs
            )
            if (pack):
                pack.add_wolf_to_pack(self)
                return

            agent = self.move_towards_own_kind(
                self.model.wolf_territorium, self.filter_func
            )
            if (agent):
                pack = Pack(
                    self.model.next_id(),
                    self.pos,
                    self.model,
                    [],
                    self.moore,
                    self.model.pack_size_threshold
                )
                self.model.schedule.add(pack)
                self.model.grid.place_agent(pack, pack.pos)
                pack.add_wolf_to_pack(agent)
                pack.add_wolf_to_pack(self)
                return
            else:
                # See if there are Elks available
                this_cell = self.model.grid.get_cell_list_contents([self.pos])
                elk = [obj for obj in this_cell if isinstance(obj, Elk)]

                if len(elk) > 0:
                    if (random.random() < self.model.wolf_lone_attack_prob):
                        elk_to_eat = self.random.choice(elk)
                        self.energy += self.model.wolf_gain_from_food

                        # Kill the elk
                        self.kills += 1
                        self.model.grid.remove_agent(elk_to_eat)
                        self.model.schedule.remove(elk_to_eat)

        # Death or reproduction
        if self.energy < 0:
            self.death()
        else:
            if self.random.random() < self.model.wolf_reproduce:
                # Create a new wolf cub
                self.energy /= 2
                cub = Wolf(
                    self.model.next_id(),
                    self.pos,
                    self.model,
                    self.moore,
                    self.energy
                )
                self.model.grid.place_agent(cub, cub.pos)
                self.model.schedule.add(cub)

    def death(self):
        """
        Removes a dead wolf from the model.
        """
        logging.debug("Wolf died.")
        self.pack = False
        self.model.grid.remove_agent(self)
        self.model.schedule.remove(self)

    # Equality operators to overrule comparison in the heapq
    def __eq__(self, other):
        self.__class__ == other.__class__ and self.pos == other.pos

    def __lt__(self, other):
        return True


class Pack(Walker):
    """
    Agent which holds a collection of wolves. Wolves are added to the pack and
    when the pack is large enough and finds an Elk, it eats and the pack is
    disbanded.
    """
    def __init__(
        self,
        unique_id,
        pos,
        model,
        wolves: list,
        moore: bool,
        pack_size_threshold: int
    ):
        """
        Create a Pack.
        Args:
            unique_id        (int): ID Generated by Mesa
            pos            (tuple): Tuple with the coordinates
            model     (mesa.Model): Model-object
            wolves          (list): List of Wolves initial
            moore           (bool): Whether the model uses Moore neighborhood.
            pack_size_threshold (int): The pack size threshold.
        """
        super().__init__(unique_id, pos, model, moore=moore)
        self.wolves = wolves
        self.min_pack = pack_size_threshold
        for wolf in wolves:
            self.add_wolf_to_pack(wolf)

    def step(self):
        """
        Step function for the Pack.
        """
        logging.debug("Wolf pack size {}".format(len(self.wolves)))
        if (len(self.wolves) < self.min_pack):
            self.find_wolf_for_pack()
            logging.debug("Pack size below minimum")
        else:
            logging.debug("Pack up to size. Start searching for Elk.")
            if (self.move_towards_specified_kind(
                    Elk,
                    self.model.wolf_territorium,
                    self.choose_elk_to_eat)
                    is None):
                # No elk found, move random.
                self.random_move()

        # Select elk to be eaten
        elk_in_radius = self.get_elk_in_radius(self.model.wolf_territorium)
        # Eat at most one elk per wolf, otherwise as much as available
        number_elk_eaten = min(len(self.wolves), len(elk_in_radius))
        chosen_elk_to_eat = self.choose_elk_to_eat(
            elk_in_radius,
            number_elk_eaten
        )

        if (
            len(chosen_elk_to_eat) > 0 and
            len(self.wolves) >= self.model.pack_size_threshold
        ):
            # Pack eats all chosen elk, pack is going to disband.
            self.pack_has_eaten(chosen_elk_to_eat)
            return

        for wolf in self.wolves:
            wolf.energy -= 1
            if (wolf.energy < 0):
                logging.debug("Wolf died while in pack")
                wolf.pack = False
                self.wolves.remove(wolf)
                continue
            if self.random.random() < self.model.wolf_reproduce:
                logging.debug("Wolf born in pack")
                wolf.energy /= 2
                cub = Wolf(
                    self.model.next_id(),
                    self.pos,
                    self.model,
                    self.moore,
                    wolf.energy
                )
                cub.pack = True
                self.wolves.append(cub)
                logging.debug("Wolf born with ID: {}".format(cub.unique_id))
        if (len(self.wolves) < 2):
            logging.debug("Disbanding small pack")
            for wolf in self.wolves:
                self.remove_from_pack(wolf)
            self.model.grid.remove_agent(self)
            self.model.schedule.remove(self)

    def filter_func_pack(self, packs):
        """
        Filter the list of packs.
        Args:
            packs (list): List of packs to filter.
        Returns:
            List of Pack agents.
        """
        return [pack for pack in packs if len(pack.wolves) < self.min_pack]

    def filter_wolves(self, agents):
        """
        Filter the list of wolves.
        Args:
            agents (list): List of wolf-agents to filter.
        Returns:
            List of Wolf agents.
        """
        return [
            agent for agent in agents
            if agent.energy < self.model.energy_threshold and not agent.pack
        ]

    def find_wolf_for_pack(self):
        """
        Find a wolf in the neighborhood.
        """
        agent = self.move_towards_specified_kind(
            Wolf, self.model.wolf_territorium, self.filter_wolves
        )
        if (agent):
            logging.debug("Next wolf found is: {}".format(agent))
            logging.debug("Pack size is now {}".format(len(self.wolves)))
            self.add_wolf_to_pack(agent)
        else:
            self.find_pack_for_pack()

    def find_pack_for_pack(self):
        """
        Find a pack in the neighborhood.
        """
        pack = self.move_towards_specified_kind(
            Pack, self.model.wolf_territorium, self.filter_func_pack
        )
        if (pack):
            logging.debug("Next pack found is: {}".format(pack))
            logging.debug("Pack size is now {}".format(len(self.wolves)))
            self.add_pack_to_pack(pack)

    def add_pack_to_pack(self, pack):
        """
        Add a pack to this pack and dissolve the other one.
        Args:
            pack (Agent): Pack-object to merge with this pack.
        """
        logging.debug("Merging packs")
        for wolf in pack.wolves:
            self.add_wolf_to_pack(wolf)
        logging.debug("Pack is now {} wolves".format(len(self.wolves)))
        self.model.schedule.remove(pack)
        self.model.grid.remove_agent(pack)

    def add_wolf_to_pack(self, wolf):
        """
        Add wolf to pack.
        Args:
            wolf (Agent): The Wolf-object to add to the pack.
        """
        logging.debug("Adding wolf {} to pack".format(wolf.unique_id))
        # When a Wolf is part of a pack
        if (not wolf.pack):
            self.model.schedule.remove(wolf)
            self.model.grid.remove_agent(wolf)
        wolf.pack = True
        self.wolves.append(wolf)

    def remove_from_pack(self, wolf):
        """
        Remove wolf from this pack.
        Args:
            wolf (Agent): The Wolf agent to remove from the pack.
        """
        logging.debug("Removing Wolf")
        logging.debug("Wolf info ID: {}, PACK: {}, POS: {}".format(
            wolf.unique_id, wolf.pack, wolf.pos)
        )
        wolf.pack = False
        self.model.schedule.add(wolf)
        self.model.grid.place_agent(wolf, self.pos)
        self.wolves.remove(wolf)

    def get_elk_in_radius(self, radius):
        """
        Checks pack radius for available elk
        Args:
            radius (int): The radius to look for elk.
        Returns:
            List of elk Agent objects.
        """
        agents_in_radius = self.model.grid.get_neighbors(
            self.pos,
            moore=True,
            include_center=False,
            radius=radius
        )
        # Get closest elks
        elk_in_radius = [
            agent for agent in agents_in_radius if isinstance(agent, Elk)
        ]

        return elk_in_radius

    def choose_elk_to_eat(self, elk, number=1):
        """
        Chooses elk to eat based on fitted polynomial to the probability
        curve of elk being killed by wolf based on age
        Args:
            elk (list): The list of Elk to choose from.
            number (int, optional): The amount of elk to eat.
        """

        if len(elk) == 0:
            return []

        def prob_killedbywolf_byage(age):
            param = self.model.elk_wolfkill_params
            degree = self.model.polynomial_degree
            return max(
                0.001, sum([param[i]*age**(degree-i) for i in range(degree+1)])
            )

        # compute absolute and relative probabilities
        P_per_elk = [prob_killedbywolf_byage(ind_elk.age) for ind_elk in elk]
        P_all_elk = [P_elk/sum(P_per_elk) for P_elk in P_per_elk]

        # control for rounding errors to have a total probability of 1
        P_all_elk[0] += 1-sum(P_all_elk)

        return np.random.choice(elk, p=P_all_elk, replace=False, size=number)

    def pack_has_eaten(self, elk_to_eat):
        """
        Pack has eaten. Add kills to wolf, add energy and disband the pack.
        Args:
            elk_to_eat (Agent): The Elk-agent to eat.
        """
        # Remove elk
        for elk in elk_to_eat:
            self.model.grid.remove_agent(elk)
            self.model.schedule.remove(elk)
        logging.debug('Pack has eated, disbanding pack with size {}'.format(
            len(self.wolves))
        )
        for wolf in self.wolves:
            wolf.energy += self.model.wolf_gain_from_food*len(elk_to_eat)
            wolf.kills += 1
            self.remove_from_pack(wolf)
        # Remove pack from scheduler
        self.model.grid.remove_agent(self)
        self.model.schedule.remove(self)

    # Equality operators to overrule comparison in the heapq.
    def __eq__(self, other):
        self.__class__ == other.__class__ and self.pos == other.pos

    def __lt__(self, other):
        return True

    def __len__(self):
        return len(self.wolves)
